# 项目开发规范

> 注意：本规范为项目开发的核心指导文件，所有代码提交必须遵循此规范。随着项目发展，本规范将不断更新和完善，规范中提到的组件功能仅为举例，不涉及实际逻辑。

## 1. 组件独立性原则

1.1 **严格遵守组件边界**：
   - 修改某个特定组件时，不得修改其他通用组件的代码或逻辑
   - 例如：修改时钟组件(clock)时，不得变更窗口组件(window)的任何代码

1.2 **通用组件保护**：
   - 通用基础组件被视为稳定核心，不应随需求变动而更改
   - 包括但不限于：窗口组件、容器组件、基础UI组件等

1.3 **例外处理流程**：
   - 若需求确实需要修改通用组件，必须先获得明确确认
   - 提出变更理由、影响范围和具体修改方案
   - 等待明确批准后方可实施

## 2. 样式编写规范

2.1 **使用LESS预处理器**：
   - 所有样式文件必须使用LESS格式（.less扩展名）编写
   - 使用浏览器端LESS编译（通过less.js），不使用预编译
   - 在HTML中使用`<link rel="stylesheet/less" type="text/css" href="文件路径.less">`方式引入
   - 确保在LESS文件之后引入less.js库

2.2 **LESS编码规范**：
   - 充分利用嵌套规则表示DOM结构层次关系
   - 使用变量定义颜色、间距、字体等可复用值
   - 复杂的样式组合使用混合(mixin)实现
   - 使用`&`符号连接伪类和修饰符

2.3 **禁用Flex布局**：
   - 不使用任何display: flex相关的样式
   - 不使用flex-direction、justify-content、align-items等flex属性
   - 采用传统布局方式(如float、position、display: block/inline-block等)

2.4 **不干扰第三方组件样式**：
   - 尊重第三方库的原始样式和布局方式
   - 避免覆盖第三方组件的核心样式
   - 需要调整时使用第三方提供的配置选项，而非覆盖其CSS

2.5 **CSS类名命名规范**：
   - 所有类名必须遵循`sl-[组件名]-[功能]`的三段式命名格式
   - 组件名必须明确标识所属组件，避免使用过于通用的名称
   - 同一组件的所有类名必须使用相同的组件名标识，例如时钟组件使用`sl-clock-xxx`
   - 组件的根容器可以使用与组件名称相同的类名，如`sl-clock`
   - 布局子元素的命名可以保持简洁，如`sl-clock-layout`
   - 对于特定功能元素（按钮、卡片、标签等），需添加明确的元素类型后缀，如`sl-clock-setting-btn`
   - 对于可能在多个组件间共享的通用样式，应添加明确的功能前缀，如`sl-common-button`
   - 组件内部的嵌套元素应使用父元素类名作为前缀，或使用LESS的嵌套功能
   
2.5.1 **类名示例**：
   | 不推荐的命名 | 推荐的命名 | 说明 |
   |-------------|------------|------|
   | sl-layout | sl-clock-layout | 缺少组件标识，无法区分属于哪个组件 |
   | sl-clock-btn | sl-clock-control-btn | 名称过于简略，不清晰表达功能 |
   | sl-tabs | sl-clock-mode-tabs | 缺少功能描述，容易与其他标签混淆 |
   | sl-clock-box | sl-clock-display | 应使用语义化命名，而非抽象的容器名称 |
   | sl-window-123 | sl-window-minimize-btn | 避免使用数字作为功能描述 |

2.5.2 **组件内元素命名**：
   - 根容器：组件名称本身即可，如`sl-clock`、`sl-window`（无需添加container后缀）
   - 主容器：当需要区分多个容器时，使用`sl-[组件名]-container`或`sl-[组件名]-wrap`
   - 布局结构：`sl-[组件名]-layout`
   - 功能区域：`sl-[组件名]-[区域功能]-area`
   - 控制元素：`sl-[组件名]-[控制功能]-control`
   - 按钮元素：`sl-[组件名]-[按钮功能]-btn`
   - 显示元素：`sl-[组件名]-[显示内容]-display`
   
2.5.3 **状态类名**：
   - 使用形容词后缀表示状态：`active`、`disabled`、`hovered`、`with-colon`等
   - 状态类名应作为修饰符添加，不应单独使用也不应加组件前缀
   - 示例：`sl-clock-tab active` 而非 `sl-active-tab` 或 `sl-clock-active-tab`
   - 示例：`sl-flipclock-digit-group with-colon` 而非 `sl-flipclock-with-colon`
   - 状态类名应表示临时状态或特征，不应包含组件标识或功能描述
   - 常见状态类名：`active`、`disabled`、`selected`、`expanded`、`collapsed`、`hidden`、`loading`等
   - 可以使用`is-`或`has-`前缀表示布尔状态特征，如`is-open`、`has-error`

2.5.4 **命名灵活性原则**：
   - 在保证组件标识清晰的前提下，可适当简化功能描述
   - 常用UI元素可使用简写（如btn代替button、nav代替navigation）
   - 组件特有的功能元素可使用更具体的描述性名称
   - 避免过度冗长的类名，在清晰和简洁间取得平衡

2.6 **样式与逻辑分离**：
   - 禁止在JS文件中使用内联样式和样式操作
   - 所有样式必须定义在对应的LESS文件中，通过类名引用
   - 动态样式应使用Vue的绑定机制（如`:class`、`:style`）实现

## 3. 组件设计原则

3.1 **模块化设计**：
   - 每个组件只负责自己的功能和视图
   - 通过清晰的API与其他组件交互，不直接操作其他组件内部

3.2 **资源管理**：
   - 组件负责管理自己创建的所有资源（DOM元素、事件监听器、定时器等）
   - 在组件销毁时清理所有资源，防止内存泄漏
   - 窗口或容器组件负责在关闭/销毁时主动调用其子组件的清理方法（如removeShortcuts）
   - 父组件不能假设子组件在自身生命周期钩子中会自动完成清理

3.3 **依赖注入**：
   - 组件间的交互通过接口进行，而非直接引用
   - 需要其他组件的功能时，通过传入引用或回调实现

## 4. 组件文件结构规范

4.1 **文件分离原则**：
   - 每个功能组件必须对应独立的JS文件和LESS文件
   - 文件命名统一使用sl-[组件名].js和sl-[组件名].less格式
   - 例如：时钟组件对应sl-clock-vue.js和sl-clock.less
   - Vue组件使用sl-[组件名]-vue.js命名格式

4.2 **目录结构规范**：
   - 项目采用分层目录结构，根据功能和文件类型组织文件
   - 所有组件JS文件必须放置在`src/components/`目录下对应组件子目录中
   - 所有样式文件必须放置在`src/styles/`目录下
   - 主要目录结构如下：
     ```
     /
     ├── src/
     │   ├── components/     # 组件目录
     │   │   ├── helloworld/  # 示例组件
     │   ├── styles/         # 所有LESS样式文件
     │   └── js/             # 其他JS文件（工具、配置等）
     ├── docs/               # 文档文件
     ├── public/             # 静态资源文件
     └── index.html          # 应用入口页面
     ```
   - 组件子目录必须与组件名称一致，全小写
   - 每个组件相关的所有JS文件必须放在其对应子目录中

4.3 **逻辑封装原则**：
   - 组件的所有逻辑必须在其JS文件中完成
   - 不在index.js或其他组件文件中编写特定组件的功能逻辑
   - 组件必须通过明确的公共API提供功能访问

4.4 **入口文件规范**：
   - index.html位于项目根目录，作为应用程序入口点
   - 入口文件仅负责组件的实例化、配置和初始化
   - 不在入口文件中编写任何具体功能实现

4.5 **导出与导入**：
   - 组件必须使用export导出，便于其他文件导入
   - 导入组件时使用import语法，指定正确的相对路径
   - 组件间导入路径必须使用相对路径（../）指向正确的组件目录
   - 在HTML中引用脚本和样式时使用基于项目根目录的相对路径（./src/...）

## 5. 代码提交规范

5.1 **功能独立性**：
   - 每次提交只涉及特定功能或组件的变更
   - 不在一次提交中混合多个不相关的变更

5.2 **代码审查**：
   - 提交前自检代码，确保无误并符合规范
   - 尤其检查是否修改了非目标组件的代码

## 6. 特殊要求

6.1 **已明确的限制事项**：
   - 不使用flex布局
   - 不修改组件预期之外的功能
   - CSS命名采用sl-xxx-格式避免冲突
   - 尊重第三方库的原始样式和实现方式

6.2 **开发流程限制**：
   - **禁止创建README文档**：开发过程中不需要编写README.md或其他说明文档
   - **禁止编写测试代码**：不需要编写任何测试代码来验证功能效果
   - **禁止启动服务**：不需要AI执行启动服务命令，服务启动由用户自行完成

6.3 **可维护性优先**：
   - 代码清晰度和可维护性优先于简洁性
   - 宁可代码略冗长但逻辑清晰，也不要过度精简导致难以理解

## 7. Vue.js组件开发规范

7.1 **使用Vue.js浏览器模式**：
   - 所有新组件必须使用Vue.js的声明式开发方式
   - 使用全局Vue对象（通过CDN引入），不使用ES模块导入Vue
   - 组件通过Vue.js的选项API定义（即对象形式），遵循Vue.js官方规范

7.2 **组件结构**：
   - 组件必须包含template、props、data、methods等标准结构
   - template使用模板字符串定义，不使用外部HTML模板
   - 组件必须通过default export导出

7.3 **组件注册与依赖管理**：
   - **子组件注册规则**：在父组件中使用子组件时，必须先导入并注册该子组件
   - **导入语法**：使用ES6 import语法导入子组件，路径必须正确指向子组件文件
   - **注册语法**：在父组件的components选项中注册所有使用的子组件
   - **常见错误**：直接在模板中使用未注册的组件会导致"Failed to resolve component"错误

7.3.1 **正确的组件依赖示例**：
   ```javascript
   // 父组件文件：src/components/parent/sl-parent-vue.js
   import ChildComponent from '../child/sl-child-vue.js';
   
   export default {
       name: 'ParentComponent',
       components: {
           ChildComponent  // 必须注册子组件
       },
       template: `
           <div class="sl-parent">
               <child-component></child-component>  <!-- 现在可以使用 -->
           </div>
       `
   };
   ```

7.3.2 **组件依赖检查清单**：
   - ✅ 是否已导入所有在模板中使用的子组件？
   - ✅ 是否在components选项中注册了所有导入的子组件？
   - ✅ 导入路径是否正确指向子组件文件？
   - ✅ 子组件文件是否正确导出了组件定义？

7.3.3 **错误排查步骤**：
   1. **检查导入语句**：确认import路径正确，文件存在
   2. **检查组件注册**：确认在components选项中注册了组件
   3. **检查组件名称**：确认模板中使用的组件名与注册名一致
   4. **检查文件导出**：确认子组件文件正确使用export default导出

7.4 **生命周期管理**：
   - 初始化工作放在mounted钩子中
   - 资源清理必须在beforeUnmount钩子中执行
   - 避免在created或beforeMount中操作DOM
   - 动态创建的子组件必须提供显式的清理方法，不能仅依赖Vue生命周期钩子
   - 在窗口关闭事件中必须主动调用子组件的清理方法，不能假设子组件的beforeUnmount会被自动触发

7.5 **状态与属性**：
   - 组件内部状态使用data选项定义
   - 组件接收的参数使用props选项定义并设置合适的验证
   - 计算属性使用computed选项定义，避免在模板中进行复杂计算

7.6 **事件处理**：
   - 使用Vue.js的事件系统进行组件间通信
   - 自定义事件通过$emit触发，避免直接调用父组件方法
   - 事件处理函数应该简洁明了，复杂逻辑应抽取为单独的方法

7.7 **指令与样式绑定**：
   - 充分利用Vue.js的指令系统（v-for、v-if、v-show等）
   - 使用:class和:style进行动态样式绑定，不使用DOM操作修改样式
   - 复杂条件渲染应使用计算属性简化模板

## 8. 常见错误与解决方案

8.1 **组件解析错误**：
   - **错误信息**：`[Vue warn]: Failed to resolve component: component-name`
   - **原因**：在模板中使用了未注册的组件
   - **解决方案**：按照7.3节的规范导入并注册组件

8.2 **路径错误**：
   - **错误信息**：模块导入失败或404错误
   - **原因**：import路径不正确
   - **解决方案**：检查相对路径，确保指向正确的文件位置

8.3 **样式不生效**：
   - **原因**：LESS文件未正确引入或类名不符合规范
   - **解决方案**：检查HTML中的样式文件引用和CSS类名命名
